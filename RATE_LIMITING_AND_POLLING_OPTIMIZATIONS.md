# Оптимизации Rate Limiting и Polling

## Проблемы, которые были решены

### 1. Ошибки 429 (Too Many Requests)
Множественные компоненты делали частые запросы к API, что приводило к превышению лимита 100 запросов в минуту.

### 2. Ошибка 500 на SSE stream
Отсутствие обработки паник в stream handlers приводило к падению сервера при ошибках.

### 3. Избыточное количество запросов
Компоненты делали запросы даже когда процессы не были активны.

## Внесенные изменения

### 1. Исключение эндпоинтов из rate limiting

**Файл:** `frontend/middleware.ts`

Добавлено 12 эндпоинтов в `RATE_LIMIT_EXCLUDED_ROUTES`:

```typescript
const RATE_LIMIT_EXCLUDED_ROUTES = [
  '/api/logs',
  '/api/quality/metrics',           // Метрики качества (каждые 30 сек)
  '/api/quality/stats',             // Статистика качества (каждые 30 сек)
  '/api/dashboard/stats',           // Статистика дашборда (каждые 30 сек)
  '/api/monitoring/metrics',        // Метрики мониторинга (каждые 30 сек)
  '/api/monitoring/providers/stream', // SSE поток провайдеров
  '/api/monitoring/events',         // События мониторинга (SSE)
  '/api/normalization/status',       // Статус нормализации (каждые 5-15 сек)
  '/api/counterparties/normalization/status', // Статус нормализации контрагентов
  '/api/kpved/workers/status',      // Статус воркеров КПВЭД (каждые 10 сек)
  '/api/dashboard/normalization-status', // Статус нормализации дашборда
  '/api/database/info',             // Информация о БД (часто запрашивается)
  '/api/quality/analyze/status',    // Статус анализа качества (каждые 2-5 сек)
]
```

### 2. Обработка ошибок в stream handlers

**Файлы:**
- `server/handlers/monitoring.go`
- `server/monitoring_handlers.go`

Добавлена обработка паник во всех stream handlers:

```go
defer func() {
    if r := recover(); r != nil {
        log.Printf("[Monitoring] Panic in getMonitoringMetrics: %v, stack: %s", r, debug.Stack())
        // Отправляем сообщение об ошибке через SSE
        fmt.Fprintf(w, "data: %s\n\n", errorMsg)
        flusher.Flush()
    }
}()
```

### 3. Улучшение обработки 429 ошибок

**Файл:** `frontend/lib/api-client.ts`

Добавлена автоматическая обработка 429 ошибок:

```typescript
// Обработка 429 (Too Many Requests) с использованием Retry-After заголовка
if (response.status === 429) {
  const retryAfter = response.headers.get('Retry-After')
  const delay = retryAfter 
    ? parseInt(retryAfter, 10) * 1000 
    : retryDelay * (attempt + 1) * 2 // Увеличиваем задержку для 429
  
  if (attempt < retries) {
    lastError = error
    await new Promise(resolve => setTimeout(resolve, delay))
    continue
  }
}
```

### 4. Оптимизация частоты polling

#### ProcessesTab
**Файл:** `frontend/components/dashboard/ProcessesTab.tsx`

- **Было:** 2 запроса каждые 5 секунд = 24 запроса/мин (всегда)
- **Стало:** 
  - 2 запроса каждые 5 секунд (если процесс запущен)
  - 2 запроса каждые 15 секунд (если процесс не запущен)
- **Экономия:** ~60% запросов в неактивном состоянии

#### Quality Analysis Progress
**Файл:** `frontend/components/quality/quality-analysis-progress.tsx`

- **Было:** 1 запрос каждую секунду = 60 запросов/мин (всегда)
- **Стало:**
  - 1 запрос каждые 2 секунды (если анализ запущен)
  - 1 запрос каждые 5 секунд (если анализ не запущен)
- **Экономия:** ~83% запросов в неактивном состоянии

#### Monitoring Page
**Файл:** `frontend/app/monitoring/page.tsx`

- **Было:** 1 запрос каждые 5 секунд = 12 запросов/мин
- **Стало:** 1 запрос каждые 10 секунд = 6 запросов/мин
- **Экономия:** 50% запросов

#### Normalization Process Card
**Файл:** `frontend/components/processes/normalization-process-card.tsx`

- **Было:** 1 запрос каждые 2 секунды = 30 запросов/мин (всегда)
- **Стало:**
  - 1 запрос каждые 2 секунды (если процесс запущен)
  - 1 запрос каждые 10 секунд (если процесс не запущен)
- **Экономия:** ~67% запросов в неактивном состоянии

#### Process Monitor
**Файл:** `frontend/components/process-monitor.tsx`

- **Было:** 1 запрос каждые 2 секунды = 30 запросов/мин (всегда)
- **Стало:**
  - 1 запрос каждые 2 секунды (если процесс запущен)
  - 1 запрос каждые 10 секунд (если процесс не запущен)
- **Экономия:** ~67% запросов в неактивном состоянии

#### Databases Pending Page
**Файл:** `frontend/app/databases/pending/page.tsx`

- **Было:** 1 запрос каждые 5 секунд = 12 запросов/мин
- **Стало:** 1 запрос каждые 10 секунд = 6 запросов/мин
- **Экономия:** 50% запросов

## Результаты оптимизации

### До оптимизации
**Сценарий:** ProcessesTab активен + анализ качества + несколько компонентов
- ProcessesTab: 24 запроса/мин
- Quality Analysis: 60 запросов/мин
- Process Cards: 30 запросов/мин × 2 = 60 запросов/мин
- **Итого:** ~144 запроса/мин

### После оптимизации
**Сценарий:** Процессы не запущены, анализ не запущен
- ProcessesTab: 8 запросов/мин (15 сек интервал)
- Quality Analysis: 12 запросов/мин (5 сек интервал)
- Process Cards: 6 запросов/мин × 2 = 12 запросов/мин (10 сек интервал)
- **Итого:** ~32 запроса/мин

**Экономия:** ~78% запросов в неактивном состоянии

## Ключевые улучшения

### 1. Условный polling
Интервалы автоматически меняются в зависимости от статуса процессов:
- Активные процессы → частые обновления (2-5 сек)
- Неактивные процессы → редкие обновления (10-15 сек)

### 2. Улучшен cleanup
Все интервалы корректно очищаются при размонтировании компонентов.

### 3. Динамическая адаптация
Частота обновлений автоматически подстраивается под активность процессов.

### 4. Защита от паник
Все stream handlers защищены от паник с логированием stack trace.

## Рекомендации

### Для разработчиков

1. **При добавлении нового polling:**
   - Используйте условный polling в зависимости от статуса
   - Увеличивайте интервал, когда процесс неактивен
   - Всегда очищайте интервалы в cleanup функции

2. **При работе с SSE:**
   - Закрывайте предыдущее соединение перед созданием нового
   - Обрабатывайте паники в stream handlers
   - Используйте экспоненциальную задержку для переподключения

3. **При работе с rate limiting:**
   - Добавляйте часто опрашиваемые эндпоинты в исключения
   - Используйте заголовок `Retry-After` для 429 ошибок
   - Настраивайте разные лимиты для разных типов запросов

### Мониторинг

Следите за:
- Количеством 429 ошибок в логах
- Частотой запросов к эндпоинтам
- Производительностью stream handlers
- Использованием памяти кэша

## Технические детали

### Rate Limiting
- **Общий лимит:** 100 запросов/мин
- **Лимит для загрузки файлов:** 10 запросов/мин
- **Лимит для чтения БД:** 200 запросов/мин
- **Окно:** 60 секунд

### Polling интервалы
- **Активные процессы:** 2-5 секунд
- **Неактивные процессы:** 10-15 секунд
- **Метрики/статистика:** 30 секунд
- **Статусы воркеров:** 10 секунд

### SSE переподключение
- **Максимум попыток:** 5
- **Начальная задержка:** 1 секунда
- **Максимальная задержка:** 30 секунд
- **Экспоненциальный рост:** 2x

## Заключение

Все оптимизации применены и протестированы. Система теперь работает стабильнее с меньшей нагрузкой на сервер. Ошибки 429 и 500 должны быть устранены.

